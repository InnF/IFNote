<h1> 工具栏
<h2> AppCompat

工具栏是 Android 5.0 (Lollipop) 之后引入的，再此之前，应用中用于导航或提供菜单操作的是操作栏。工具栏是基于操作栏进化而来。原生的工作栏无法支持更老版本的系统，不过，Google 已将它移植到了AppCompat库。这样，老版本系统也可以使用 Lollipop 上的工作栏了。

<h4>使用AppCompat库

要完全整合AppCompat库，还需要：
  + 添加AppCompat依赖项
  + 使用一种AppCompat主题

     AppCompat库自带以下三种主题：
    - `Theme.Appcompat`：黑色主题
    - `Theme.Appcompat.Light`：浅色主题
    - `Theme.Appcompat.Light.DarkActionBar`：带黑色工具栏的浅色主题
  + 确保所有 activity 都是 AppCompatActivity 子类

<h2> 工具栏菜单

<h4>在 XML 文件中定义菜单

在项目工具窗口中，右键单击 res 目录，选择 New -> Android resource file 菜单项。在弹出的窗口界面，选择 Menu 资源类型，并命名，点击 OK 按钮确认。

 + 应用命名空间

    **注意** 不同于常见的android命名空间声明，Menu 的 xml 文件使用 xmlns 标签定义全新的app命名空间

    _**Eg:**_

    ```xml
    <menu
      xmlns:android="http://schemas.android.com/apk/res/android"
      xmlns:app="http://schemas.android.com/apk/res-auto">
      <item
          android:id="@+id/menu_item_new_crime"
          android:icon="@android:drawable/ic_menu_add"
          android:title="@string/new_crime"
          app:showAsAction="ifRoom|withText"
          />
    </menu>
    ```
    上面的代码中，icon 指定了菜单的图标，用的是Android自带的图标，再看 showAdAction 属性，它用于指定菜单选项是显示在工具栏上，还是隐藏于* 溢出菜单（ overflow menu ）*。指定 ifRoom 和 withText 的组合值，即只要空间足够，菜单项图标及其文字都会显示在工具栏上。如果空间仅够显示图标，文字描述就不会显示。如空间大小不够显示任何项，菜单项就会隐藏到溢出菜单中。属性 showAsAction 还有另外两个可选值：always 和 never 。不推荐使用 always ，应尽量使用 ifRoom， 让操作系统如何显示菜单项。

    因为 AppCompat 库不希望使用原生 showAsAction 属性，因此，它提供了定制版 showAsAction 属性( app:showAsAction ),这就需要命名空间`xmlns:app="http://schemas.android.com/apk/res-auto"`

    **PS** 溢出菜单即工具栏最右端带有三个点的图标

+ 使用 Android Asset Studio

  应用使用的图标有两种，系统图标（即系统内置图标）和项目资源图标。android:icon 的属性值 @android:drawable/ic_menu_add 就引用了系统图标。

  我们也可以用Android Studio 内置的 Android Asset Studio 工具为工具栏定制图标。使用步骤：右键单击 drawable 目录，选择 New -> Image Asset 菜单项，在弹出的窗口中的Asset Type: 中选择 Action Bar and Tab Icons，确定 Foreground 选项为 Clipart，然后单击 Choose 按钮挑选图标。

+ 创建菜单

  以下为创建菜单和响应菜单项选择事件的两个回调方法：

   `public void onCreateOptionsMenu(Menu menu, MenuInflater inflater)`

   `public boolean onOptionsItemSelected(MenuItem item)`

   - 实例化菜单

   _**Eg:**_
   ```Java
   @Override
   public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
       super.onCreateOptionsMenu(menu, inflater);
       inflater.inflate(R.menu.fragment_crime_list,menu);

    }
   ```
   以上方法中，调用 MenuInfalter.inflate(int, menu) 方法并传入菜单文件的字眼ID，将布局文件中定义的菜单项目填充到Menu实例中。

   **注意** 如果是在 fragment 中，调用 Fragment.onCreateOptionsMenu(Menu, MenuInfalter)方法，是由FragmentManager负责调用的。因此，当activity接受到操作系统的 onCreateOptionsMenu(···) 方法回调请求时，我们必须明确告诉 FragmentManager：其管理的 fragment 应接收 onCreateOptionsMenu(···) 方法的调用指令。要通知 FragmentManager，需在 Fragment.onCreate(···) 方法中调用以下方法：

   ```public void setHasOptionsMenu(boolean hasMenu)```

   _**Eg:**_

   ```java
   @Override
    public void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setHasOptionsMenu(true);
    }
   ```
   - 响应菜单项选择
    ```java
    @Override
  public boolean onOptionsItemSelected(MenuItem item) {
      switch (item.getItemId()) {
          case R.id.menu1:
              // TO-DO
              return true;
          case R.id.menu2:
              // TO-DO
              return true;
          default:
              return super.onOptionsItemSelected(item);
      }
    ```
    一旦完成菜单项事件处理，应返回true值以表明全部任务完成。另外，默认case表达式中，如果菜单项ID不存在，超类版本方法会被调用

<h2> 拓展

<h4> 实现层级式导航

  *层级式导航（ hierarchical navigation, 有时又称为 ancestral navigation ）*可在应用内逐级向上导航。在 Jelly Bean  （ API 16）设备之后，可轻松实现层级式导航，但在此之前，开发者只能自己动手处理向上按钮的显示和点击事件

  打开 _AndroidManifest.xml_ 文件。(假设有两个Activity，*FirstActivity* 和 *SecondActivity*)

  ```xml
  <activity android:name=".SecondActivity"
          android:label="@string/app_name"
          android:parentActivityName=".FirstActivity">
  </activity>
  ```

  * 层级导航的工作原理

    用户点击向上按钮自 *SecondActivity* 界面向上导航时，如下的intent会被创建：
    ```java
      Intent intent = new Intent(this, SecondActivity。class);
      intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
      startActivity(intent);
      finish();
    ```    
    FLAG_ACTIVITY_CLEAR_TOP 指示 Android 在回退栈中寻找指定activity实例。如存在，则弹出栈内所有其他Activity，让启动的目标activity出现在栈顶（显示在屏幕上）

<h4> 显示子标题

  首先在要显示子标题的Menu文件下
  ```xml
  <item
      android:id="@+id/menu_item_show_subtitle"
      android:title="@string/show_subtitle"
      android:showAsAction="ifRoom"
      />
  ```

  然后再 `public boolean onOptionsItemSelected(MenuItem item)` 方法下，添加逻辑：

  ```java
  @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            ···
            case R.id.menu_item_show_subtitle:
                String subtitle = "要显示的自标题内容"
                AppCompatActivity activity = (AppCompatActivity) getActivity();
                activity.getSupportActionBar().setSubtitle(subtitle);
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }
  ```
